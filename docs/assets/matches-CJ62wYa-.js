import{s as l}from"./dataManager-CtWei30S.js";new Date().toISOString().slice(0,10);async function z(r){var d,s;try{if(console.log(`Starting deletion of match ${r}`),!r||typeof r!="number")throw new Error("Invalid match ID provided for deletion");const{data:h,error:w}=await l.from("matches").select("date,prizeaek,prizereal,goalslista,goalslistb,manofthematch,yellowa,reda,yellowb,redb").eq("id",r);if(w)throw console.error("Error fetching match:",w),w;if(!h||h.length===0){console.warn(`Match with id ${r} not found`);return}const t=h[0];t.date||console.warn(`Match ${r} has no date - this may cause issues with transaction cleanup`),console.log("Deleting match data:",t);const b={financialChanges:[],playerGoalChanges:[],sdsChanges:[]};console.log(`Fetching transactions for match ${r} before deletion`);const{data:A,error:$}=await l.from("transactions").select("team,amount,type").eq("match_id",r);if($)throw console.error("Error fetching transactions:",$),$;const i=A||[];if(console.log(`Found ${i.length} transactions to reverse:`,i.map(e=>`${e.type}: ${e.amount} (${e.team})`)),console.log(`Reversing financial changes for ${(i==null?void 0:i.length)||0} transactions`),i&&i.length>0)for(const e of i)if(e.type==="Echtgeld-Ausgleich"){const{data:n,error:o}=await l.from("finances").select("debt").eq("team",e.team);if(o){console.error(`Error fetching finances for team ${e.team}:`,o);continue}const a=n&&n.length>0?n[0]:null,f=(a==null?void 0:a.debt)||0;let c=f-e.amount;c<0&&(c=0),b.financialChanges.push({team:e.team,type:"debt",oldValue:f,newValue:c}),await l.from("finances").update({debt:c}).eq("team",e.team)}else{const{data:n,error:o}=await l.from("finances").select("balance").eq("team",e.team);if(o){console.error(`Error fetching finances for team ${e.team}:`,o);continue}const a=n&&n.length>0?n[0]:null,f=(a==null?void 0:a.balance)||0;let c=f-e.amount;c<0&&(c=0),b.financialChanges.push({team:e.team,type:"balance",oldValue:f,newValue:c}),await l.from("finances").update({balance:c}).eq("team",e.team)}if(typeof t.prizeaek=="number"&&t.prizeaek!==0){const{data:e,error:n}=await l.from("finances").select("balance").eq("team","AEK");if(n)console.error("Error fetching AEK finances:",n);else if(e&&e.length>0){const o=e[0];let a=((o==null?void 0:o.balance)||0)-t.prizeaek;a<0&&(a=0),await l.from("finances").update({balance:a}).eq("team","AEK")}}if(typeof t.prizereal=="number"&&t.prizereal!==0){const{data:e,error:n}=await l.from("finances").select("balance").eq("team","Real");if(n)console.error("Error fetching Real finances:",n);else if(e&&e.length>0){const o=e[0];let a=((o==null?void 0:o.balance)||0)-t.prizereal;a<0&&(a=0),await l.from("finances").update({balance:a}).eq("team","Real")}}console.log(`Deleting ${(i==null?void 0:i.length)||0} transactions for match ${r}`);const{error:y}=await l.from("transactions").delete().eq("match_id",r);if(y)throw console.error("Error deleting transactions:",y),y;const{data:g,error:S}=await l.from("transactions").select("id").eq("match_id",r);if(S)console.warn("Could not verify transaction deletion:",S);else{if(g&&g.length>0)throw console.error(`‚ùå Failed to delete ${g.length} transactions for match ${r}`),new Error(`Transaction deletion incomplete: ${g.length} transactions still exist`);console.log(`‚úÖ Successfully deleted all transactions for match ${r}`)}const q=async(e,n)=>{if(!e||!Array.isArray(e))return;const o={};if(e.length>0&&typeof e[0]=="object"&&e[0].player!==void 0)e.forEach(a=>{a.player&&(o[a.player]=(o[a.player]||0)+(a.count||1))});else for(const a of e)a&&(o[a]=(o[a]||0)+1);for(const[a,f]of Object.entries(o)){const{data:c,error:m}=await l.from("players").select("goals").eq("name",a).eq("team",n);if(m){console.error(`Error fetching player ${a} for goal removal:`,m);continue}if(!c||c.length===0){console.warn(`Player ${a} not found in team ${n} for goal removal`);continue}const u=c[0];let p=((u==null?void 0:u.goals)||0)-f;p<0&&(p=0);const{error:k}=await l.from("players").update({goals:p}).eq("name",a).eq("team",n);k?console.error(`Error updating goals for player ${a}:`,k):console.log(`‚úÖ Updated goals for ${a} (${n}): ${u.goals} ‚Üí ${p}`)}};if(await q(t.goalslista,"AEK"),await q(t.goalslistb,"Real"),t.manofthematch){let e=null;const n=(o,a)=>!o||!o.length?!1:typeof o[0]=="object"&&o[0].player!==void 0?o.some(f=>f.player===a):o.includes(a);if(n(t.goalslista,t.manofthematch))e="AEK";else if(n(t.goalslistb,t.manofthematch))e="Real";else{const{data:o,error:a}=await l.from("players").select("team").eq("name",t.manofthematch);a?console.error(`Error fetching player ${t.manofthematch} for team lookup:`,a):o&&o.length>0?e=o[0].team:console.warn(`Player ${t.manofthematch} not found for SdS team determination`)}if(e){const{data:o,error:a}=await l.from("spieler_des_spiels").select("count").eq("name",t.manofthematch).eq("team",e);if(a)console.error(`Error fetching SdS entry for ${t.manofthematch}:`,a);else if(o&&o.length>0){const f=o[0],c=Math.max(0,f.count-1),{error:m}=await l.from("spieler_des_spiels").update({count:c}).eq("name",t.manofthematch).eq("team",e);m?console.error(`Error updating SdS count for ${t.manofthematch}:`,m):console.log(`‚úÖ Updated SdS count for ${t.manofthematch} (${e}): ${f.count} ‚Üí ${c}`)}else console.warn(`SdS entry for ${t.manofthematch} in team ${e} not found`)}}(t.yellowa>0||t.reda>0||t.yellowb>0||t.redb>0)&&console.log(`Match had cards: AEK(${t.yellowa}Y,${t.reda}R) Real(${t.yellowb}Y,${t.redb}R)`),console.log(`Deleting match ${r} from matches table`);const{error:E}=await l.from("matches").delete().eq("id",r);if(E)throw console.error("Error deleting match:",E),E;const{data:M,error:v}=await l.from("matches").select("id").eq("id",r);if(v)console.warn("Could not verify match deletion:",v);else{if(M&&M.length>0)throw console.error(`‚ùå Failed to delete match ${r}`),new Error(`Match deletion failed: match ${r} still exists`);console.log(`‚úÖ Successfully deleted match ${r}`)}console.log(`‚úÖ Successfully deleted match ${r} and all related data`),console.log(`üìã Deletion Summary for Match ${r}:`),console.log("   - Match record: deleted"),console.log(`   - Transactions: ${i.length} deleted`),console.log(`   - Player goals: updated for ${((d=t.goalslista)==null?void 0:d.length)||0} AEK + ${((s=t.goalslistb)==null?void 0:s.length)||0} Real goals`),console.log(`   - Player of the match: ${t.manofthematch?"updated":"none"}`),console.log(`   - Prize money: AEK ${t.prizeaek||0}, Real ${t.prizereal||0} (reversed)`),console.log(`   - Match date: ${t.date}`)}catch(h){throw console.error(`Failed to delete match ${r}:`,h),alert(`Fehler beim L√∂schen des Spiels: ${h.message}`),h}}window.showMatchStatistics=function(){if(matches.length===0){alert("üìä Keine Spiele vorhanden f√ºr Statistiken");return}const r={totalMatches:matches.length,aekWins:matches.filter(s=>(s.goalsa||0)>(s.goalsb||0)).length,realWins:matches.filter(s=>(s.goalsb||0)>(s.goalsa||0)).length,draws:matches.filter(s=>(s.goalsa||0)===(s.goalsb||0)).length,totalGoals:matches.reduce((s,h)=>s+(h.goalsa||0)+(h.goalsb||0),0),highestScore:Math.max(...matches.map(s=>Math.max(s.goalsa||0,s.goalsb||0))),averageGoals:0};r.averageGoals=(r.totalGoals/r.totalMatches).toFixed(1);const d=`üèÜ Match-Statistiken:

Gesamt: ${r.totalMatches} Spiele
AEK Siege: ${r.aekWins}
Real Siege: ${r.realWins}
Unentschieden: ${r.draws}

Tore gesamt: ${r.totalGoals}
√ò Tore/Spiel: ${r.averageGoals}
H√∂chstes Ergebnis: ${r.highestScore} Tore`;alert(d)};export{z as deleteMatch};
